#!/usr/bin/python3

# The entry point for the application. Creates the controller and handles
# high-level config e.g. debug level etc. Note the log level can be
# customised by passing an integer on the command line:
#
# Level     Value
# CRITICAL  50
# ERROR     40
# WARNING   30
# INFO      20
# DEBUG     10
# NOTSET    0
from argparse import ArgumentParser
from os import environ
from signal import SIGINT, SIGTERM, signal

from app import App
from pitop.common.logger import PTLogger
from systemd.daemon import notify

# Set the display env var
environ["DISPLAY"] = ":0.0"

# Process command line
parser = ArgumentParser(description="pi-top hardware manager")
parser.add_argument(
    "--log-level",
    type=int,
    help="set the logging level from 10 (more verbose) to 50 (less verbose)",
    default=20,
)
args = parser.parse_args()

PTLogger.setup_logging(logger_name="pt-device-manager", logging_level=args.log_level)

# Create the app
app = App()


def signal_handler(unused_signal, unused_frame):
    app.stop()


# Capture and handle interrupts
signal(SIGINT, signal_handler)
signal(SIGTERM, signal_handler)


# Start the app
successful_start = app.start()
notify("STOPPING=1")

if not successful_start:
    PTLogger.error("Unable to start pi-top device manager")
    app.stop()

# Exiting with 1 will cause systemd service to restart - we should only do this if we failed to determine a device ID
exit(0 if app.device_id is not None else 1)
